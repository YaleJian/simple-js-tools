[{"title":"结语","type":0,"sectionRef":"#","url":"/simple-js-tools/blog/end","content":"记录一下，今天把Simple JS Tools的文档网站搭建完成，使用的是Docusaurus，还挺灵活好用的。 怎么使用？ 这个js库已经打包压缩放在了NPM库中。 npm i simple-js-tools ","keywords":""},{"title":"初始创立","type":0,"sectionRef":"#","url":"/simple-js-tools/blog/first","content":"","keywords":""},{"title":"历史背景​","type":1,"pageTitle":"初始创立","url":"/simple-js-tools/blog/first#历史背景","content":"Javascript作为一个脚本语言，却经常被用来当作计算机语言来用，日常的开发使用中，除了浏览器支持的W3C标准API，并没有一个简单、易用的JS库，所以我总结了一些常用方法的库，它是面向函数的。 "},{"title":"比较","type":0,"sectionRef":"#","url":"/simple-js-tools/docs/API/compare","content":"","keywords":""},{"title":"判断是否为数组​","type":1,"pageTitle":"比较","url":"/simple-js-tools/docs/API/compare#判断是否为数组","content":"isArray(arg) { return Array.isArray(arg) }  "},{"title":"判断是否为对象​","type":1,"pageTitle":"比较","url":"/simple-js-tools/docs/API/compare#判断是否为对象","content":"isObject(arg){ return Object.prototype.toString.call(arg) === '[object Object]' }  "},{"title":"判断是否为Promise对象​","type":1,"pageTitle":"比较","url":"/simple-js-tools/docs/API/compare#判断是否为promise对象","content":"isPromise(arg){ return Object.prototype.toString.call(arg) === '[object Promise]' }  "},{"title":"前言","type":0,"sectionRef":"#","url":"/simple-js-tools/docs/API/intro","content":"","keywords":""},{"title":"历史背景​","type":1,"pageTitle":"前言","url":"/simple-js-tools/docs/API/intro#历史背景","content":"Javascript作为一个脚本语言，却经常被用来当作计算机语言来用，日常的开发使用中，除了浏览器支持的W3C标准API，并没有一个简单、易用的JS库，所以我总结了一些常用方法的库，它是面向函数的。 "},{"title":"设计想法​","type":1,"pageTitle":"前言","url":"/simple-js-tools/docs/API/intro#设计想法","content":"在设计之初，就确立了每一个方法应该简单、最优，始终相信，最成熟的方法一定是最简单的，最优秀的方法应该同时兼顾方案更简单、* *性能更好、更安全**。 "},{"title":"谦虚的心态​","type":1,"pageTitle":"前言","url":"/simple-js-tools/docs/API/intro#谦虚的心态","content":"所有的方法来自个人的原创、网络搜索到结果的总结，难免有方法不够简单、性能不是最好，甚至有漏洞，所以欢迎大家的指正和建议，GitHub已开放了反馈和讨论。 "},{"title":"编码流程​","type":1,"pageTitle":"前言","url":"/simple-js-tools/docs/API/intro#编码流程","content":"先有设计文档全网调研编码发布 "},{"title":"对象","type":0,"sectionRef":"#","url":"/simple-js-tools/docs/API/object","content":"","keywords":""},{"title":"深拷贝​","type":1,"pageTitle":"对象","url":"/simple-js-tools/docs/API/object#深拷贝","content":"deepCopy(...args) { //初始化变量 let target = args[0] || {}, i = 1, length = args.length, options, name, src, copy, copyIsArray, clone //传入一个变量时，自身合并参数对象 if (length === 1) { target = this i = 0 } //循环拷贝 for (; i &lt; length; i++) { options = args[i] if (!options) continue //只处理不是undefined和null的值 for (name in options) { copy = options[name] //要拷贝的对象属性 if (name === &quot;_proto_&quot; || target[name] === copy) continue //只处理值不同的,不改变_proto_ //属性值为数组和对象需要进一步拷贝 if (copy &amp;&amp; (Compare.isObject(copy) || (copyIsArray = Compare.isArray(copy)))) { src = target[name] //原来对象属性 if (copyIsArray &amp;&amp; !Compare.isArray(src)) { //copy是数组，但是原来对象属性不是数组 clone = [] } else if (!copyIsArray &amp;&amp; !Compare.isObject(src)) { //copy不是数组，原来对象属性不是对象 clone = {} } else { clone = src } copyIsArray = false //避免影响下次循环 target[name] = object.deepCopy(clone, copy) } else if (copy !== undefined) { target[name] = copy } } } return target }  "},{"title":"快速上手","type":0,"sectionRef":"#","url":"/simple-js-tools/docs/API/快速上手","content":"","keywords":""},{"title":"安装​","type":1,"pageTitle":"快速上手","url":"/simple-js-tools/docs/API/快速上手#安装","content":""},{"title":"通过 npm 安装​","type":1,"pageTitle":"快速上手","url":"/simple-js-tools/docs/API/快速上手#通过-npm-安装","content":"在现有项目中使用 simple-js-tools 时，可以通过 npm 进行安装 npm i simple-js-tools  当然，你也可以通过 yarn 或 pnpm 进行安装： # 通过 yarn 安装 yarn add simple-js-tools # 通过 pnpm 安装 pnpm add simple-js-tools  "},{"title":"通过 CDN 安装​","type":1,"pageTitle":"快速上手","url":"/simple-js-tools/docs/API/快速上手#通过-cdn-安装","content":"使用 simple-js-tools 最简单的方法是直接在 HTML 文件中引入 CDN 链接，之后你可以通过全局变量 sTools 访问到所有方法。 &lt;script src=&quot;https://unpkg.com/browse/simple-js-tools@1.0.0-beta.3/dist/simple-js-tools.js&quot;&gt; &lt;/script&gt;  "},{"title":"XMLHttpRequest","type":0,"sectionRef":"#","url":"/simple-js-tools/docs/API/xhr/XMLHttpRequest","content":"","keywords":""},{"title":"模拟XMLHttpRequest对象​","type":1,"pageTitle":"XMLHttpRequest","url":"/simple-js-tools/docs/API/xhr/XMLHttpRequest#模拟xmlhttprequest对象","content":"// 备份原生 XMLHttpRequest window._XMLHttpRequest = window.XMLHttpRequest window._ActiveXObject = window.ActiveXObject /* PhantomJS TypeError: '[object EventConstructor]' is not a constructor (evaluating 'new Event(&quot;readystatechange&quot;)') https://github.com/bluerail/twitter-bootstrap-rails-confirm/issues/18 https://github.com/ariya/phantomjs/issues/11289 */ try { new window.Event('config') } catch (exception) { window.Event = function (type, bubbles, cancelable, detail) { let event = document.createEvent('CustomEvent') // MUST be 'CustomEvent' event.initCustomEvent(type, bubbles, cancelable, detail) return event } } let XHR_STATES = { // The object has been constructed. UNSENT: 0, // The open() method has been successfully invoked. OPENED: 1, // All redirects (if any) have been followed and all HTTP headers of the response have been received. HEADERS_RECEIVED: 2, // The response's body is being received. LOADING: 3, // The data transfer has been completed or something went wrong during the transfer (e.g. infinite redirects). DONE: 4 } let XHR_EVENTS = 'readystatechange loadstart progress abort error load timeout loadend'.split(' ') let XHR_REQUEST_PROPERTIES = 'timeout withCredentials'.split(' ') let XHR_RESPONSE_PROPERTIES = 'readyState responseURL status statusText responseType response responseText responseXML'.split(' ') // https://github.com/trek/FakeXMLHttpRequest/blob/master/fake_xml_http_request.js#L32 let HTTP_STATUS_CODES = { 100: &quot;Continue&quot;, 101: &quot;Switching Protocols&quot;, 200: &quot;OK&quot;, 201: &quot;Created&quot;, 202: &quot;Accepted&quot;, 203: &quot;Non-Authoritative Information&quot;, 204: &quot;No Content&quot;, 205: &quot;Reset Content&quot;, 206: &quot;Partial Content&quot;, 300: &quot;Multiple Choice&quot;, 301: &quot;Moved Permanently&quot;, 302: &quot;Found&quot;, 303: &quot;See Other&quot;, 304: &quot;Not Modified&quot;, 305: &quot;Use Proxy&quot;, 307: &quot;Temporary Redirect&quot;, 400: &quot;Bad Request&quot;, 401: &quot;Unauthorized&quot;, 402: &quot;Payment Required&quot;, 403: &quot;Forbidden&quot;, 404: &quot;Not Found&quot;, 405: &quot;Method Not Allowed&quot;, 406: &quot;Not Acceptable&quot;, 407: &quot;Proxy Authentication Required&quot;, 408: &quot;Request Timeout&quot;, 409: &quot;Conflict&quot;, 410: &quot;Gone&quot;, 411: &quot;Length Required&quot;, 412: &quot;Precondition Failed&quot;, 413: &quot;Request Entity Too Large&quot;, 414: &quot;Request-URI Too Long&quot;, 415: &quot;Unsupported Media Type&quot;, 416: &quot;Requested Range Not Satisfiable&quot;, 417: &quot;Expectation Failed&quot;, 422: &quot;Unprocessable Entity&quot;, 500: &quot;Internal Server Error&quot;, 501: &quot;Not Implemented&quot;, 502: &quot;Bad Gateway&quot;, 503: &quot;Service Unavailable&quot;, 504: &quot;Gateway Timeout&quot;, 505: &quot;HTTP Version Not Supported&quot; } /* MiniXMLHttpRequest */ function MiniXMLHttpRequest() { // 初始化 config 对象，用于存储自定义属性 this.config = { events: {}, headers: {}, } //返回hook this.proxy = false this.debug = false } object.deepCopy(MiniXMLHttpRequest, XHR_STATES) object.deepCopy(MiniXMLHttpRequest.prototype, XHR_STATES) // 标记当前对象为 MiniXMLHttpRequest MiniXMLHttpRequest.prototype.mini = true // 禁止代理 MiniXMLHttpRequest.prototype.noProxy = false // 初始化 Request 相关的属性和方法 object.deepCopy(MiniXMLHttpRequest.prototype, { // https://xhr.spec.whatwg.org/#the-open()-method // Sets the request method, request URL, and synchronous flag. open: function (method, url, async, username, password) { let that = this object.deepCopy(this.config, { method: method, url: url, async: typeof async === 'boolean' ? async : true, username: username, password: password, body: '', options: { url: url, method: method, } }) function handle(event) { // 同步属性 NativeXMLHttpRequest =&gt; MiniXMLHttpRequest for (let i = 0; i &lt; XHR_RESPONSE_PROPERTIES.length; i++) { try { that[XHR_RESPONSE_PROPERTIES[i]] = xhr[XHR_RESPONSE_PROPERTIES[i]] } catch (e) { } } // 触发 MiniXMLHttpRequest 上的同名事件 that.dispatchEvent(new Event(event.type /*, false, false, that*/)) } // 禁止代理时，则采用原生 XHR 发送请求。 if (this.noProxy || this.proxy) { // 创建原生 XHR 对象，调用原生 open()，监听所有原生事件 let xhr = createNativeXMLHttpRequest() this.config.xhr = xhr // 初始化所有事件，用于监听原生 XHR 对象的事件 for (let i = 0; i &lt; XHR_EVENTS.length; i++) { xhr.addEventListener(XHR_EVENTS[i], handle) } if (username) { xhr.open(method, url, async, username, password) } else { xhr.open(method, url, async) } // 同步属性 MiniXMLHttpRequest =&gt; NativeXMLHttpRequest for (let j = 0; j &lt; XHR_REQUEST_PROPERTIES.length; j++) { try { xhr[XHR_REQUEST_PROPERTIES[j]] = that[XHR_REQUEST_PROPERTIES[j]] } catch (e) { } } return } // 开始拦截 XHR 请求 this.readyState = MiniXMLHttpRequest.OPENED this.dispatchEvent(new Event('readystatechange' /*, false, false, this*/)) }, // https://xhr.spec.whatwg.org/#the-setrequestheader()-method // Combines a header in author request headers. setRequestHeader: function (name, value) { // 原生 XHR if (this.noProxy || this.proxy) { this.config.xhr.setRequestHeader(name, value) return } // 拦截 XHR let headers = this.config.headers if (headers[name]) headers[name] += ',' + value else headers[name] = value }, timeout: 0, withCredentials: false, upload: {}, // https://xhr.spec.whatwg.org/#the-send()-method // Initiates the request. send: function send(data) { let that = this this.config.body = data this.config.timeout = this.timeout // 原生 XHR if (this.noProxy || this.proxy) { this.config.xhr.send(data) return } // 拦截 XHR // X-Requested-With header this.setRequestHeader('X-Requested-With', 'MiniXMLHttpRequest') // loadstart The fetch initiates. this.dispatchEvent(new Event('loadstart' /*, false, false, this*/)) that.readyState = MiniXMLHttpRequest.HEADERS_RECEIVED that.dispatchEvent(new Event('readystatechange' /*, false, false, that*/)) that.readyState = MiniXMLHttpRequest.LOADING that.dispatchEvent(new Event('readystatechange' /*, false, false, that*/)) if (MiniXMLHttpRequest.proxy) { if (MiniXMLHttpRequest.debug) console.log(&quot;[XHR] 请求xhr:&quot;, that.config) let doProxy = MiniXMLHttpRequest.proxy(that) if(compare.isPromise(doProxy)){ doProxy.then(data =&gt; { done(data) }).catch(e =&gt; { done(e, 502) }) } } else { console.warn(&quot;[tools-xhr] proxy param is not a Promise&quot;) } function done(data, status) { if (MiniXMLHttpRequest.debug) console.log(&quot;[XHR] 响应data:&quot;, data) if (data.responseHeaders) that.responseHeaders = data.responseHeaders if (data.response) that.response = data.response || '' if (typeof data.response === &quot;string&quot;) that.responseText = data.response if (data.responseType) that.responseType = data.responseType if (data.responseURL) that.responseURL = data.responseURL if (data.responseXML) that.responseXML = data.responseXML that.status = data.status || 200 that.statusText = data.statusText || HTTP_STATUS_CODES[that.status] if (data.timeout) that.timeout = data.timeout if (data.withCredentials) that.withCredentials = data.withCredentials that.readyState = MiniXMLHttpRequest.DONE that.dispatchEvent(new Event('readystatechange' /*, false, false, that*/)) that.dispatchEvent(new Event('load' /*, false, false, that*/)); that.dispatchEvent(new Event('loadend' /*, false, false, that*/)); } }, // https://xhr.spec.whatwg.org/#the-abort()-method // Cancels any network activity. abort: function abort() { // 原生 XHR if (this.noProxy) { this.config.xhr.abort() return } // 拦截 XHR this.readyState = MiniXMLHttpRequest.UNSENT this.dispatchEvent(new Event('abort', false, false, this)) this.dispatchEvent(new Event('error', false, false, this)) } }) // 初始化 Response 相关的属性和方法 object.deepCopy(MiniXMLHttpRequest.prototype, { status: MiniXMLHttpRequest.UNSENT, statusText: '', // https://xhr.spec.whatwg.org/#the-getresponseheader()-method getResponseHeader: function (name) { // 原生 XHR if (this.noProxy || this.proxy) { return this.config.xhr.getResponseHeader(name) } // 拦截 XHR return this.responseHeaders[name.toLowerCase()] }, // https://xhr.spec.whatwg.org/#the-getallresponseheaders()-method // http://www.utf8-chartable.de/ getAllResponseHeaders: function () { // 原生 XHR if (this.noProxy || this.proxy) { return this.config.xhr.getAllResponseHeaders() } // 拦截 XHR let responseHeaders = this.responseHeaders let headers = '' for (let h in responseHeaders) { if (!responseHeaders.hasOwnProperty(h)) continue headers += h + ': ' + responseHeaders[h] + '\\r\\n' } return headers }, overrideMimeType: function ( /*mime*/) { }, responseHeaders: {}, responseURL: '', responseType: '', // '', 'text', 'arraybuffer', 'blob', 'document', 'json' response: null, responseText: '', responseXML: null }) // EventTarget object.deepCopy(MiniXMLHttpRequest.prototype, { addEventListener: function addEventListener(type, handle) { let events = this.config.events if (!events[type]) events[type] = [] events[type].push(handle) }, removeEventListener: function removeEventListener(type, handle) { let handles = this.config.events[type] || [] for (let i = 0; i &lt; handles.length; i++) { if (handles[i] === handle) { handles.splice(i--, 1) } } }, dispatchEvent: function dispatchEvent(event) { let handles = this.config.events[event.type] || [] for (let i = 0; i &lt; handles.length; i++) { handles[i].call(this, event) } let ontype = 'on' + event.type if (this[ontype]) this[ontype](event) } }) // Inspired by jQuery function createNativeXMLHttpRequest() { let isLocal = function () { let rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/ let rurl = /^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/ let ajaxLocation = location.href let ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [] return rlocalProtocol.test(ajaxLocParts[1]) }() return window.ActiveXObject ? (!isLocal &amp;&amp; createStandardXHR() || createActiveXHR()) : createStandardXHR() function createStandardXHR() { try { return new window._XMLHttpRequest(); } catch (e) { } } function createActiveXHR() { try { return new window._ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } catch (e) { } } } export default MiniXMLHttpRequest  "}]